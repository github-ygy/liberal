事务的特性
    原子性:指事务包含的所有操作要么全部成功，要么全部失败回滚
    一致性:指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态
    隔离性:数据库开启的每一个事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离
    持久性:一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的

数据库的隔离级别
    读未提交:一个事务还未提交，它所做的变更就可以被其它事务看到
    读提交:一个事务提交以后，它所做的变更才可以被别的事务看到
    可重复读:一个事务执行过程中看到的数据是一致的，未提交的更改对其它事务是不可见的。
    串行化:加锁串行化执行，后访问到的事务必须等前一个事务执行完成才能继续执行

事务隔离的实现
    每条记录在更新的时候都会同时记录一条回滚操作，事务数据由存储事务Id通过回滚日志获取之前的数据。
    create-version delete-version存储事务Id
    删除版本号未指定或者大于当前事务版本号，即查询事务开启后确保读取的行未被删除
    创建版本号 小于或者等于 当前事务版本号 ，就是说记录创建是在当前事务中
    对于可重复读，查询只承认在事务启动前就已经提交完成的数据（包括当前读，数据事务id与当前事务id一直的数据）
    对于读提交，查询只承认在语句启动前就已经提交完成的数据
    a、利用MVCC实现一致性非锁定读，这就有保证在同一个事务中多次读取相同的数据返回的结果是一样的，解决了不可重复读的问题
    b、利用Gap Locks和Next-Key可以阻止其它事务在锁定区间内插入数据，因此解决了幻读问题

为什么尽量不要使用长事务
    a)锁定太多的数据，造成大量的阻塞和锁超时，回滚所需要的时间比较长。
    b)执行时间长，容易造成主从延迟
    c)长事务以为这系统里面会存在很老的事务视图，会占用存储空间。

删除数据三种方式如何选择
    a.一次性删除100000条数据 （锁定行记录多，占用锁资源时间长，大事务）
    b.for循环多次少量删除 （资源分片使用，减少锁时间的占用,提高并发）
    c.同时启动多个个链接每条sql删除少量条数据 （死锁检测,浪费cpu资源;多个线程对同一行操作的容易造成死锁）

对比B+树索引与hash索引的区别

普通索引与唯一索引的区别，写多读少如何选择索引
    对于普通索引的修改，会将修改操作记录到change buffer中，并同时记录到redo log，
    当需要读取数据或后台后台线程再将change buffer写入磁盘。(记录change buffer减少随机读）
    唯一索引因为要先读后写所以无法使用change buffer（判断索引的唯一性）
    （change buffer主要减少了随机读的io，redo log将随机写转化为顺序写）
    读数据时，会从磁盘读出数据merge change buffer数据传给应用，记录redo log，此时内存数据则
    和磁盘数据不一致，成为脏页，后续要走脏页刷盘的流程。

如果突然重启，内存中change buffer丢失，数据如何保持一致性


为什么表数据删除一半，表文件大小不变


