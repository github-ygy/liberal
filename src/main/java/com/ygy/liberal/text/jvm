类加载机制（双亲委派模型）

新建的对象一定会进入新生代吗？

gc算法有哪些？(有哪些垃圾回收机制)

class文件只会加载一次吗？如果实现class加载多次

tomcat实现热部署的原理

Object a = new Object()内存中是怎样分配的？

int a = 1 内存是如何分配的？

java内存模型8大原子操作

怎么判断对象是否被回收？

java中的引用类型

jvm中的垃圾回收算法有哪些？

新生代垃圾回收器和老生代垃圾回收器有什么区别？

分代垃圾回收器的工作机制？


垃圾回收算法：
    标记清除:1阶段标记GcRoot不可达对象，二阶段清除淘汰数据，会存在内存不连续。
    复制算法:将现有空间分为两块，每次使用其中一块，垃圾回收时，将存活对象复制到未使用的内存块中
    标记整理:在标记清除的基础中优化碎片空间，整理内存不连续空间。

垃圾回收器原理
    cms
        触发条件
            a.周期性触发,根据是否达到阈值进行判断是否要进行Gc
            2.主动触发，老年代的空间不够年轻代对象
        处理过程
            1.初始化标记(stop the world)
                a.标记GcRoot可达的老年代对象
                b.遍历新生代标记可达的老年代对象
            2.并发标记（老年代对象变化还是较少的）
                a.遍历初始化标记的存活对象，继续递归标记这些对象可达的对象
                b.对于此阶段在新生代晋升、老年代分配的对象、更新引用等对象记录下来
            3.重新标记（stop the world）
                为何要有重新标记
                    a.老年代的对象重新被GcRoots引用
                    b.老年代的未标记对象被新生代对象引用
                    c.引用被删除等一系列情况
                可优化方式，重新标记前执行一次YoungGC，可减少新生代对象的重新标记
                    （缺点：如果新生代对象本来就很少，需要多一次YoungGc）
                重新标记对象
                    a.遍历新生代对象,重新标记
                    b.根据GcRoot，重新标记
                    c.遍历老年代的dirtyCrard重新标记
         压缩
            1.使用参数，设置多少次Gc后进行压缩
            2.主动进行了System.gc()
            3.如果新生代的晋升担保失败
         concurrent mode failure
            并发模式失败，jvm会自动转变为Serial Old进行垃圾回收，会增大停顿时间
            可能原因
                1.新生代提升速度过快，老年代收集速度赶不上新生代
                2.老年代碎片化严重，无法容纳新生代提升上来的大对象
            解决办法
                （1）如果频率太快的话，说明空间不足，首先可以尝试调大新生代空间和晋升阈值。
                （2）如果内存有限，可以设置 CMS 垃圾收集在老年代占比达到多少时启动来减少问题发生频率（默认68 XX:CMSInitiatingOccupancyFraction ）
                 3）如果频率太快或者 Full GC 后空间释放不多的话，说明空间不足，首先可以尝试调大老年代空间
                 4）如果内存不足，可以设置进行 n 次 CMS 后进行一次压缩式（UseCMSCompactAtFullCollection，CMSFullGCBeforeCompaction）




去永久代采用元数据?
     (1）字符串存在永久代中，容易出现性能问题和内存溢出。
    （2）永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
    （3）元数据采用本地内存可避免溢出问题

如果判断对象可gc回收
    1.引用计数法，无法解决环的问题，造成内存泄漏
    2.rootGc可达性（对象作为起始节点，利用图论，可达对象便是存活对象，而不可达对象则是需要回收的垃圾内存）
        root节点：a.全局性引用(静态变量或常量),b.局部变量表中的引用对象

内存溢出
    a.堆内存溢出(年轻代，老年代溢出 -Xms -Xmx -Xmn -NewRatio -SurvivorRatio)
    b.栈溢出（栈太深 -Xss）
    c.元数据溢出（原永久代）
    d.直接内存溢出（nio操作直接内存时可能会溢出）


GC正常执行标准
    MinorGC 执行时间不到50ms；
    Minor GC 执行不频繁，约10秒一次；
    Full GC 执行时间不到1s；
    Full GC 执行频率不算频繁，不低于10分钟1次。








