1.tcp与udp的区别，具体使用场景。
     TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，
  确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，
  因此应用层可以忽略所有这些细节
    UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，
  但并不保证该数据报能到达另一端。任何必需的可靠性必须由应用层来提供

http协议与tcp有什么区别

http1.0与2.0的区别

https协议与http的区别

OSI的七层模型？

tcp的粘包是什么


为什么tcp需要握手？
    tcp是可靠性通信，接收方收到的数据是完整、有序、无差错的。
        通信双方需要判断自己已经发送的数据包是否都被接收方收到，
        如果没收到，就需要重发。为了实现这个需求，很自然地就会引出序号（sequence number）
        和 确认号（acknowledgement number） 的使用
为什么tcp是三次握手，而非两次
    发送方和接收方始终需要同步序号。
    A ——> syn(标记链接) seq = x  B处于监听状态
    B --> syn(标记链接) seq y ack x+1 （确认x+1）
    A --> ack y+1 确认B的序号 A处于单方面建立链接状态
    B 接收到A的ack 建立与A的链接
tcp的四次挥手过程？
    A ——> fin (A进入Fin wait1状态 可以接收和应答数据，但是不能主动发数据)
    B --> ack (A进入Fin wait2状态 做自己关闭前的处理后发送fin）
    B --> fin (A进入time_wait 等待关闭链接状态)
    A --> ack (A进入关闭状态 等待2MSL是如果对象没有收到ack会再次发送fin此时可以再次应答ack关闭链接)

    异常关闭常见问题
        1.代码层面上未对连接进行关闭，比如关闭代码未写在 finally 块关闭，如果程序中发生异常就会跳过关闭代码，
        自然未发出指令关闭，连接一直由程序托管，内核也无权处理，自然不会发出 FIN 请求，导致连接一直在 CLOSE_WAIT
        2.程序响应过慢，比如双方进行通讯，当客户端请求服务端迟迟得不到响应，就断开连接，
        重新发起请求，导致服务端一直忙于业务处理，没空去关闭连接。这种情况也会导致这个问题。

流量控制和拥塞控制什么区别？
    一个是对另一个端的，一个是针对网络的
    流量控制：滑动窗口协议
    拥塞控制主要避免：包丢失和超时重传
        BBR控制
        一旦空间被占满会流入缓存空间，这时马上进行降速，直到有空间时，再继续慢启动

io多路复用select epoll
    select函数监听文件描述符集合是否有变化，轮询判断变化进行处理，有最大处理数量
    epoll则为事件通知，有变化会进行通知，根据通知处理（红黑树存储效率更高）

http2.0的优化
    通过头压缩，分帧，二进制编码，多路复用等技术提升性能

dns解析的过程
    1.访问本地DNS解析器读取本地缓存
    2.访问本地dns服务器读取本地缓存数据
    3.访问根域名服务器--->顶级域名服务器
    4.顶级域名服务器--->权威域名服务器
    5.得到一个或多个真是ip地址轮训访问最近的服务资源
    



