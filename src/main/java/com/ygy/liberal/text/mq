谈谈消息发送的高可用
    采用重试和规避
        默认会重试3次消息发送，会规避上次失败的broker，规避策略是轮训机制 + 延迟容错

谈谈rocket mq 的message queue消息队列负载均衡机制
   策略是轮训机制 + 延迟容错
        如果开启了延迟容错:
            1.轮训queue，如果仍为上一次调用的broker或者新的broker则判断是否达到可用状态，否走下一步
            2.从延迟容错容器中选择一个相对可用的broker（按照可用时间排序后从排在前面可用的1/2开启轮训选择）
            3.否则，轮训选择一个非上一个失败broker的broker queue


根据消息偏移量查找？commitlog
    offset /mappedFileSize - mappedFile.getFileFromOffset()/this.mappedFileSize

consumeQueue与commitlog的关系
    consumeQueue是commitlog文件的索引文件，其构建机制是当消息当大commitlog文件后，由专门的线程
    产生消息转发任务，从而构建消息消费队列(commitlog offset size  taghashcode)

index file
    每个slot中放的指针值是索引在indexFile中的偏移量，
    每个索引大小是20字节，所以根据当前索引是这个文件中的第几个（偏移量），
    就很容易定位到索引的位置。然后每个索引都保存了跟它同一个slot的前一个索引的位置，
    以此类推形成一个链表的结构

mq如何判断索引文件不一致需要重建
    1.创建abort文件，注册jvm钩子退出时删除，如果下次启动检查存在，则为异常退出
    2.根据是否异常退出重构索引文件
    3.重构文件可能会带来消息的重复

mq如何失败重传消息？
    为了保证消息是肯定被至少消费成功一次，RocketMQ会把这批消息重发回Broker
    （topic不是原topic而是这个消费租的RETRY topic），
    在延迟的某个时间点（默认是10秒，业务可设置）后，
    再次投递到这个ConsumerGroup。而如果一直这样重复消费都持续失败到一定次数（默认16次），
    就会投递到DLQ死信队列。应用可以监控死信队列来做人工干预。

消息队列负载均衡原理
    1.后台线程20s进行一次队列负载
    2.获取主题队列信息(mqset)与消费组当前所有的消费者(cidAll)
    3.计算当前消费者分配到消息队列集合
        a.平均分配
        b.平均轮训分配
        c.一致性hash
        d.根据配置
        e.根据broker部署机房名
    4.对比原先的负载队列与此处分配队列
    5.如果新队列集合不包含原先的队列则停止原先队列消息消费并移除
    6.如果原先队列中不包含新分配的队列则创建新的pullRequest(后台线程阻塞队列take拉取)

消息进度设计
    //消费启动时查询消费进度开始拉取消息消费
    1.消息ack后更新的是消费消息中最小的偏移量保证消息至少可消费一次
    2.如果批量拉取消息中的偏移量跨度大于2000自动施行流控，消息将延迟拉取
    3.如果某条消息长时间没有ACK，超过一定时间将会自动ack，默认是15分钟（后台任务定时扫描所有消费信息的消费时间）

消息为何会被重复消费
    消费端
        1.消息消费负载均衡20s计算，新点加入或有点挂点时会出现重复消费
        2.消息进度都是以最小的消息确认，可能出现重启后重复消费的情况
    broker端
        索引文件刷盘异常等情况，校对和重构的过程可能重复构建

定时消息原理
    1.如果发送消息的delayLevel大于0，则改变消息主题为Schedule_topic_xxx，消息队列id为delaylevel -1
    2.消息经由commitlog转发到消息消费队列Schedule_topic_xxx的消费队列中
    3.定时任务每隔固定时间根据上次偏移量从消息队里中取出所有消息
    4.根据物理偏移量和消费大小从commitlog中拉取消息
    5.根据消息属性重新创建消息，回复原消息主题原队列id清除延迟属性，重新存入commitlog
    6.消息被正常消费

 消息重试？
    重试是基于定时消息
    1.消费者开始会自动订阅消费 topic和retry-topic
    2.如果消费失败将会重新发送到retry-topic进行消费
    3.根据消费次数重新改变消费主题为Schedule_topic_xxx基于定时消息重试消息















